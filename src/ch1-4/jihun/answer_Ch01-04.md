### ✔️ 미나
1. jdk와 jre차이 
- JDK(Java Development Kit)는 Java 프로그램을 개발하고 실행할 수 있는 환경을 제공하는 반면 JRE는 Java 프로그램을 실행하는 환경만을 제공한다. JDK의 경우, 자바 플랫폼의 SDK(Software Development Kit)로, 프로그램을 작성하는데 필요한 도구를 제공한다. 이 안에는 JRE가 포함되어 있다. JRE(Java Runtime Environment)는 다른 소프트웨어를 실행하도록 설계된 소프트웨어의 일부로 클래스 라이브러리, 로더 클래스 및 JVM이 포함되어 있다. 디버거, 컴파일러 등과 같은 Java 개발을 위한 도구를 포함하지 않는다.
2. 컴파일과 빌드 차이
- 먼저 빌드란 소스 코드 파일을 실행할 수 있는 독립적인 파일을 만드는 것. 반면 컴파일은 소스코드를 바이너리 형태로 변경하는 것. 즉, 빌드를 한다는 것은 컴파일 한다는 것을 포함하는 개념이다. 
3. jvm의 역할
- 자바 애플리케이션을 클래스 로더를 통해 읽어 Java Byte Code 를 자바 API(자바를 사용하여 쉽게 구현할 수 있도록 한 클래스 라이브러리의 집합)와 함께 실행하는 것 
- 메모리 정리(GC)
4. primitive type이란?
- 원시 타입은 정수, 실수, 문자, 논리 리터럴등의 실제 데이터 값을 저장하는 타입이다. 이와 대립되는 개념으로 참조 타입은 변수에 해당 정보를 가지고 있는 메모리 주소를 저장하는 타입이다. 원시 타입은 흔히 아는 int, char 등이 포함되고 참조 타입은 객체, 배열 등이 포함된다.
5. 변수 사용 범위에 따라, 각각 사용 위치에 따른 특징
- 
***

### ✔️ 재환
1. JVM 의 특징을 설명하세요
- 스택 기반의 가상머신. vs 레지스터 기반:하드웨어에 덜 의존적이며, 명령어 크기가 작다.
- 가비지 컬렉션 수행
- 플랫폼 독립적 
2. 자동 타입 변환이 무엇인지 설명하세요
- 작은 크기를 가지는 타입의 변수를 큰 크기 타입에 대입할 때, 자동으로 형변환이 일어난다. 묵시적 형변환이라고도 한다.  
3. 오버플로우/언더플로우 가 무엇인지 설명하세요
- 변수에 할당된 메모리공간을 넘어설 때 발생하는 문제, 오버플로우는 최댓값보다 큰 값을 넣을 경우 최솟값부터 시작하는 경우이고 언더플로우는 그 반대이다.
4. while 문과 do~while 문의 차이점에 대해 설명하세요
- while은 루프를 들어가기 전에 조건을 점검하지만 do while은 먼저 명령을 수행하고 루프를 계속할지 여부를 판단한다.  
5. 정수를 입력받으면 해당 정수가 짝수인지 홀수인지 판별하는 코드를 작성하세요
```
if(변수%2==0) System.out.println("짝수"); 
else System.out.println("홀수");
```
***

### ✔️ 광민
1. JVM의 동작 방식에 대해 서술해주세요.
- 간단하게 요약하면 바이트 코드를 클래스 로더에 전달하고, 클래스 로더는 동적 로딩을 통해 필요한 클래스들을 Runtime Data Area(메모리)에 올린다. 실행 엔진은 메모리에 올라온 바이트 코드들을 명령어 단위로 가져와 실행한다.  
2. 데드락과 데드락이 발생하는 조건에 대해 서술해주세요.
- 데드락은  Ready Queue 안의 프로세스들이 서로가 가진 자원을 기다리며 block 되어 더 이상 진행이 될 수 없는 상태 즉, 서로가 서로를 기다리고 있는 상태이다.원인은 상호배제, 보유대기, 비선점, 순환대기가 있을 경우 발생한다.  
3. 데드락을 예방하는 방법과 데드락을 해결하는 방법을 서술해주세요.
-  데드락을 예방하는 방법은 자원 할당 시 데드락의 4가지 필요 조건 중 어느 하나가 만족되지 않도록 하는 것이다. 
- 데드락을 해결하는 방법은 데드락이 탐지될 경우 해당 프로세스를 강제 종료시키거나, 프로세스의 자원을 선점하는 방식을 사용해 해결한다.
4. 생성자 선언 후 nullpointerexception 사용 시 참조형을 사용하면 안되는 이유를 서술해주세요.
5. equals, contains, ==의 차이점을 서술해주세요.
- ==과 equal의 차이 : == 동일성 비교, equals 동등성 비교, 따라서 ==는 주소값을 비교 equal은 멤버변수 비교
- equals과 contains : String에서 equals는 같은 문자열을 가지는지, contains는 해당 문자열을 포함하는지 판단하는 함수이다. 또한 contains는 인수가 null이면 NullPointerException 발생시키지만 equals는 그렇지 않다.


***
### ✔️ 지훈
1. 자바 컴파일 과정에 대해 설명하시오.
- 자바 소스코드(.java)를 작성
- 자바 컴파일러가 자바 소스코드(.java)파일을 읽어 바이트코드(.class)코드로 컴파일(JVM(자바 가상 머신)이 읽을 수 있는 코드)
- 컴파일된 바이트코드(.class)를 JVM의 클래스로더(Class Loader)에게 전달한 뒤, 클래스 로더는 동적로딩(Dynamic Loading)을 통해 필요한 클래스들을 로딩 및 링크하여 런타임 데이터 영역(Runtime Data Area), 즉 JVM의 메모리에 올림
- 실행엔진(Execution Engine)은 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행. 이때 인터프리터 형식(명령어를 하나씩 읽어서 해석하고 실행)과 JIT 컴파일러(바이너리 코드 전체를 컴파일하여 바이너리 코드로 변경, 하니씩 해석하지 않기 때문에 실행 속도가 빠름) 형식이 있음. 
2. 자바는 모든 운영체제에서 실행 가능하다. 어떻게 이것이 가능한지 설명하시오. 그리고 컴파일 언어와 인터프리터 언어의 특징에 대해 설명하시오
- JVM 덕분에 가능하다. 자바 컴파일 과정에서 알 수 있듯 먼저 .class로 변환한 뒤, JVM 위에서 OS에 맞게 해석하여 실행한다. 이 때문에 운영체제에 맞는 JVM이 필요하다. 
- 컴파일언어는 코드를 모아서 한번에 오브젝트 파일 만들고 링커로 라이브러리 등을 엮음 이 과정에서 최적화가 일어나고 실행파일이 만들어져서 실행만 하면 됨 속도가 빠름. 반면 인터프리터는 한줄씩 해석하여 실행하기 때문에 속도가 느림. 대신에 OS에 맞춰 변역을 해주기 때문에 운영체제에 무관하게 실행 가능
3. byte에서 char 형으로 형 변환 시, 자동 형 변환이 불가능한 이유에 대해 설명하시오
- byte는 음수를 포함하나, char의 경우 음수를 포함하지 않는다. 이 때문에, char가 더 크지만 자동 형변환이 불가능하다. 
4. int a = 32768;을 (short)a, (char)a으로 각각 강제 형변환할 경우, 발생하는 일에 대해 설명하시오 
- short의 경우 overflow가 발생한다. 반면 char의 경우 최대 범위가 65535이므로 overflow가 발생하지 않는다.
5. if문과 switch ~ case문의 차이를 설명하시오.  
- if문은 조건문의 결과가 true일 때, 스코프 내의 코드가 실행되도록 하는 분기점이다. 반면 switch 문의 경우, 특정 변수의 값에 따라 서로 다른 코드가 실행되도록 정해진 영역으로 이동하도록 하는 목적이 있다. 
- 어셈블리 관점에서 본다면 switch문의 경우, case가 충분히 많을 경우 jump table이 만들어져 성능적인 측면에서 효율적일 수 있다.  

***

### ✔️ 지우
1. 강제 타입 변환과 자동 타입 변환에 대해 작성하기
- 강제 타입 변환은 큰 크기를 가지는 타입의 변수를 작은 크기 타입에 대입할 때, 정보 손실을 감수하고 명시적으로 형변환을 실행시키는 방식이다. 
- 자동 타입 변환은 이미 설명.
2. 다음 연산으로 실행되는 데이터 타입 작성하기
(1)-byte : int 
(2)byte+byte : int 
(3)int+long : long
3. 정수를 입력받고, 7로 나누었을 때 나머지가 0이 아니면 "X"출력 후 반복, 0이면 "종료"출력 후 종료되는 반복문 코드 작성하기
```
int num;
Scanner sc = new Scanner(System.in);
while(true){
    num = sc.nextInt();
    if(num%7==0) {
        System.out.println("종료");
        break;
    }
    else System.out.println("X");
}
```
4. 2023년 1월 1일을 printf() 메서드를 이용하여 출력하는 코드 작성하기
```
System.out.printf("%d년 %d월 %d일",2023,1,1);
```
5. ++피연산자, 피연산자++ 설명하기
- 전위 연산자의 경우, 1이 증가된 값이 연산 결과값이고 후위 연산자의 경우 증가하기 이전 값이 연산 결과값이다. 따라서 만약 출력할 경우, ++변수의 경우 이전 값에 1이 증가된 값이 출력되고 변수++의 경우 증가되기 이전 값이 출력되고 +1 연산이 수행된다. 
