
***
### ✔️ 광민
1. 기본형과 참조형 타입에 대해 설명해주세요.
- 기본형 변수는 stack에 실제 값을 저장하여 사용하며, 참조형은 마치 객체를 저장하는 것처럼 Heap에 실제 값을 저장하고 해당 주소를 stack에 저장하는 방식을 사용
2. 싱글톤에 대해 설명해주세요.
- 어플리케이션이 시작될 때 어떤 클래스가 최초 한번만 메모리를 할당하고(static) 그 메모리에 인스턴스를 만들어 사용하는 디자인 패턴, 객체의 인스턴스가 단 하나만 존재함
3. 오버로딩과 오버라이딩에 대해 설명해주세요.
- 메소드 오버라이딩은: 자식 객체가 부모와는 다른 동작을 하도록 메소드를 재정의하는 과정이다. 즉, 메소드(동작)의 개념이다.
- 메소드 오버로딩(다중정의): 함수의 이름은 같고, 인자의 개수나 자료형이 다른 함수들을 프로그램이 자동으로 구분하는 것. 즉 동작은 동일하고 파라미터의 차이가 있다
4. public, protected, default, private에 대해 설명해주세요.
- 접근제어자, protected는 외부 패키지 사용 x, default는 상속 관계 사용 x, private은 외부클래스 사용 x 
5. 인스턴스 멤버와 정적 멤버에 대해 설명해주세요.
- 인스턴스 멤버는 객체(인스턴스)를 생성한 뒤 사용할 수 있는 필드와 메소드이다. 인스턴스 필드와 메소드는 객체에 소속된 멤버이기 때문에 객체 없이는 사용할 수 없다.
- 정적 멤버는 객체가 아닌 클래스에 고정(static)된 멤버이다. 클래스 로더에 의해 클래스 바이트 코드를 메소드 영역에 올려놓을 때 함께 올라간다. 따라서 객체 생성 없이 사용할 수 있다.
 

***
### ✔️ 재환
1. 메모리 영역에 대해 설명하세요. 
- Code 영역
    - 프로세스가 실행할 코드와 매크로 상수가 기계어의 형태로 저장된 공간
    - 컴파일 타임에 결정되고 중간에 코드를 바꿀 수 없게 Read-Only 로 지정돼있다.
- Data 영역
    - 코드에서 선언한 전역변수 또는 static 변수
    - 등등이 저장된 공간이다. 전역변수/static 값을 참조한 코드는 컴파일 하고 나면 Data 영역의 주소값을 가르키도록 바뀐다. 실행 중도에 전역변수가 변경 될 수도 있으니 이 영역은 Read-Write로 지정돼있다. 단, 초기화 되지 않는 전역 변수는 BSS 영역에 할당된다.
- 스택
    - 함수 안에서 선언된 지역변수, 매개변수, 리턴값, 돌아올 주소 등등이 저장되고 함수 호출시 기록하고 종료되면 제거
        - 기본 자료형의 경우 데이터 자체가 스택에 저장
        - 반면 참조 자료형의 경우 실**제 데이터의 주소값만 스택에 저장**하며 실제 참조 자료형 데이터는 heap 영역에 존재
        - 스택에 쌓이는 변수에는 객체의 좌표를 저장하기 위한 공간만 존재하여 참조 변수(Reference Variable)이라고 하며, 객체의 좌표값은 참조값(Reference Value)라고 부른다.
    - 공유되지 않음
    - 스택은 함수 콜마다 스택 프레임이 쌓여감
    - 컴파일 타임에 크기가 결정되기 때문에 무한히 할당 할 수 없다. 재귀함수가 너무 깊게 호출되거나 함수가 지역변수를 너무 많이 가지고 있어 stack 영역을 초과하면 stack overflow 에러가 발생
- Heap
    - 동적으로 할당된 객체가 저장
        - 런타임에 할당(미리 할당하는 것은 비효율성 증가)
        - 프로그래머가 필요할 때마다 사용하는 메모리 영역. Code, Data, Stack 영역과는 다르게 Heap은 런타임에 결정된다
    - 힙 영역에는 주로 긴 생명주기를 가지는 데이터들이 저장된다.
    - 대부분의 오브젝트는 크기가 크고, 서로 다른 코드블럭에서 공유되는 경우가 많다
2. 생성자에 대해 설명하세요. 
- 처음 객체가 생성될 때, new 연산자를 통해서 인스턴스를 생성할 때 반드시 호출이 되고 제일 먼저 실행되는 일종의 메소드(하지만 메소드와는 다르다.)이다.
- 생성자는 인스턴스 변수를 초기화 시키는 용도. 즉, 객체 변수에 값을 무조건 설정하기 위해 만든 메소드라고 보면 된다.
3. 정적 맴버에 대해 설명하세요. 
- 위와 동일
4. 접근 제한자에 대해 설명하세요. 
- 위와 동일
5. 싱글톤 패턴에 대해 설명하세요. 
- 위와 동일
***
### ✔️ 지훈
1. 객체는 메모리상 어디에 생성되는가, 또 어떻게 메모리를 해제하는가 
- 힙 메모리란 객체가 생성되는 메모리 공간을 뜻한다. 메모리 공간에서는 아래의 그림과 같이 생성된다. 스택 영역에는 참조변수(객체의 주소가 담겨있음)가 생성되고, 실제 객체는 힙 메모리 영역에 생성된다
- 가비지컬렉터에 의해 해제된다.
2. Call by value 와 Call by Reference 차이, 자바의 call by reference
- value는 값을 복사해주는 방식, reference 주소값을 넣어주는 방식 그래서 로컬 환경에서 값을 변경하면 로컬만 변함, 레퍼런스에 주소의 값을 변경한다. 간단하게 말해 메소드의 인자를 넣어 값을 바꾼다면 로컬 변수로 취급되기 때문에 리턴해서 메인 메소드에서 바꿔주지 않는 이상 객체 변수 값은 바뀌지 않는다.
3. 자바에서 파라미터로 객체를 넘기는 것은 Call by Reference인가
- 객체를 파라미터로 넣어주면 안에서 변경하면 값을 변경된다. 그치만 레퍼런스라고 보기는 어렵다. 왜냐하면 새로운 객체를 생성하고 그것을 가르키게 하는 방식이기 때문이다.
4. 객체지향의 특징 중 캡슐화와 은닉성에 대해 설명하시오.
- 외부와의 결합력은 낮추고 내부끼리의 응집성은 높이는 것이 목적이다. 말 그대로 캡슐처럼 만든다는 이야기다. 캡슐처럼 객체의 속성과 메소드를 하나로 묶는 것이다. 
- 그리고 이렇게 캡슐화가 되면 우리가 캡슐 안을 볼 수 없듯 메서드 안에서 어떠한 일이 일어나고 있는지 모르므로 은닉 또한 일어난다. 
- 다만 은닉화는 객체에서 속성을 직접 접근하지 못하게 숨기는 것이므로 캡슐화가 되었다고 반드시 정보 은닉이 일어나는 것은 아니다.

***
### ✔️ 지우
1. nullPointerException은 언제 발생하는지 설명해주세요.
- 만약 변수가 null인 상태에서 이에 데이터나 메소드를 사용하려고 하면 nullpointer exception 발생
2. 배열 변수를 선언한 시점과 값을 대입하는 시점이 다를 시 
값을 대입하는 법을 설명해주세요.
- new 연산자를 사용 
3. 캡슐화에 대해 설명해주세요.
- 위와 동일
4. 라이브러리 클래스와 실행 클래스에 대해 설명해주세요.
- 라이브러리클래스: 해당 클래스가 가진 기능을 실행클래스에 제공함, 메인메소드를 가지지 않고, 메인메소드를 가진 실행클래스에 의해 호출되어 사용됨
- 실행클래스 : 메인메소드를 가진 클래스, 별다른 기능을 가지지 않고 프로그램의 시작만 담당하는 역할
5. getter와 setter에 대해 설명해주세요.
- 객체의 필드를 외부에서 맘으대로 읽고 변경할 경우, 객체의 무결성이 깨질 수 있다.
- 따라서 외부에서 직접적인 접근을 막고 getter와 setter를 통해 필드를 변경한다.
***
### ✔️ 미나
1. JVM의 메모리 영역에 대해 설명해주세요.
- 위와 동일
2. String 객체 생성시, new연산자를 쓰면 같은 문자열이더라도 서로 다른 번지를 가진다.
    <br> 이떄 equals를 사용하여 비교하면 true가 나오는데, 그렇게 나올 수 있는 이유는?
- equals를 뜯어보면 내부의 값을 비교하고 있기 때문
3. static 키워드에 대해 설명해주세요.
- tatic 키워드는 정적 변수 (static variable)를 선언하기 위해서 사용하는 키워드, 객체 생성 없이 변수나 함수를 사용 가능하다. 
- 클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통적으로 사용해야하는 것에 static을 붙인다.
- static이 붙은 메서드(함수)에서는 인스턴스 변수를 사용할 수 없다
4. this 키워드에 대해 설명해주세요.
- this는 객체 자기 자신을 지칭하는 명령어다. 멤버 변수와 지역 변수가 같은 이름인 경우, 특수한 변수 this를 사용하여 멤버 함수 참조가 가능하다.
- this는 자기 자신의 객체를 나타내는 변수로 인스턴스 메소드 내에서 사용된다. this.변수명으로 사용된다. 
- 또한 객체 자신을 인수로 다른 메소드를 호출하는 경우에도 사용된다.
- this() 메소드는 클래스의 다른 생성자를 호출하는 함수이며 staic메소드와 main 메소드에서는 쓸 수 없다. 또한 생성자처럼 가장 먼저 호출되어야하므로 첫줄에 써야한다. this()는 생성자 내부에서만 써야한다.