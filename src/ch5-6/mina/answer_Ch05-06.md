
***
### ✔️ 광민
1. 기본형과 참조형 타입에 대해 설명해주세요.
   - 기본형(primitive type)
     - 8가지의 타입이 있다 (boolean, char, byte, short, long, int, float, double)
     - 리터럴 그대로 실제 값이 스택 영역에 저장된다.(p.145)
     - null을 담을 수 없다.
   - 참조형(reference type)
     - 기본형 외 타입 모두
     - 스택 영역에 주소값을 저장하고, 실제 값은 heap영역에 저장되어 있다.(p.145)
     - null을 담을 수 있다
   1. 싱글톤에 대해 설명해주세요.
      - 객체의 인스턴스가 오직 한개만 생성되는 패턴
      - 어떤 클래스가 최초 한번만 메모리를 할당(static)하고, 그 메모리에 객체를 만들어 사용함 
      - 생성자 호출이 반복적으로 이뤄져도 실제로 생성되는 객체는 최초 생성된 객체를 반환해주는 것 
      ```java
      public class Singleton{
          //private, static로 객체를 한개만 만듦!
          private static Singleton instance = new Singleton();
          //생성자, 외부에서 접근(호출) 불가
          private Singleton(){
          }
          
          public static Singleton getInstance() {
          return instance;
          }
          
        ```
      
      - 최초 한번의 new연산자로 고정된 메모리 영역 사용
      - 전역으로 사용되는 인스턴스
      - 동시성 문제 발생할 수 있음

   
2. 오버로딩과 오버라이딩에 대해 설명해주세요.
   - 오버로딩
     - 이름은 동일하지만 파라미터 순서, 수, 타입은 다른 메서드 중복 정의 가능
     - 메서드 시그니쳐: 메서드 명, 파라미터 순서, 타입, 개수 의미.(리턴 타입과 exception은 아님) 
     - 메서드 시그니쳐가 같은 메서드는 같은 클래스에 존재할 수 없음.
     - 컴파일 타임에 결정 됨 (클래스 메타 정보에서 메서드들이 구분된 상태로 저장됨, 별개의 메서드 취급)
       - 정적바인딩 : 컴파일 시간에 성격이 결정되는 것
   
   - 오버라이딩
     - 상속관계에 있는 클래스간 같은 이름의 메서드 재정의 -> 다형성과 관계
     - 런타임에 결정됨.
       - 동적바인딩 : 다형성을 사용하여 메서드 호출 시 발생하는 현상. 런타임시 성격이 결정됨.
       

3. public, protected, default, private에 대해 설명해주세요.
    - 접근지정자
      - public : 모든 접근 허용.
      - protected : 상속받은 클래스 또는 같은 패키지에서만 접근 가능
      - default : 기본 제한자. 자신 클래스 내부와 같은 패키지내에서만 접근 가능
      - private : 외부에서 접근 불가. 같은 클래스 내에서만 접근 가능


4. 인스턴스 멤버와 정적 멤버에 대해 설명해주세요.
   1. 인스턴스 멤버 
      - 객체(인스턴스)를 생성한 뒤 사용할 수 있는 필드와 메서드
        - 각각 인스턴스 필드와 인스턴스 메서드라고 부름.
      - 인스턴스 필드와 메서드는 객체에 소속된 멤버 이기때문에 객체 없이 사용 불가
      - 객체마다 가지고 있어야 하는 데이터는 인스턴스 필드로 선언.
   2. 정적 멤버
      - 객체가 아닌 클래스에 고정(static)된 멤버. 
      - 객체 생성하지 않고도 사용 가능.
      - 객체마다 가지고 있을 필요성 없는 상수또는 유틸리티의 경우 정적멤버로 선언
      - 클래스에 고정되어 있기 때문에, 클래스 로더에 의해 클래스 바이트 코드를 메서드 영역에 올려놓을 때
        함께 올라감.
      - 필드와 메서드 선언 시 static 키워드 붙여 주면 됨.
      - 프로그램 시작~종료시까지 메모리에 존재.
      - 클래스 이름과 도트(.)연산자로 접근.
      - 객체 자신의 참조인 this 키워드 사용 불가.
   

***
### ✔️ 재환
1. 메모리 영역에 대해 설명하세요.
   1. Method area
      - 모든 스레드가 공유하는 메모리 영역. 클래스, 인터페이스, 메서드, 필드, static 변수 등 바이크 코드 보관
   2. Head area
      - 모든 스레드가 공유. new키워드로 생성된 객체와 배열이 생성되는 영역.
      - 메서드 영역에 로드된 클래스만 생성가능. GC가 참조되지 않는 메모리 확인하고 제거함
   3. Stack area
      - 메서드 호출마다 각각의 stack frame 생성됨. 그 메서드안에서 사용되는 값들 저장
      - 호출된 메서드의 매개변수, 지역변수, 리턴 및 연산 시 일어나는 값들을 임시로 저장
      - 메서드 수행이 끝나면 프레임별로 삭제 
2. 생성자에 대해 설명하세요.
   - 인스턴스가 생성될 때 호출되는 '인스턴스 초기화 메서드'
   - 생성자의 이름은 클래스 이름과 동일하며, 리턴값이나 void 키워드 붙이지 않는다.
   
3. 정적 맴버에 대해 설명하세요. 
   - 위에서 설명함 
4. 접근 제한자에 대해 설명하세요.
   - 위에서 설명함
5. 싱글톤 패턴에 대해 설명하세요.
   - 위에서 설명함 

***
### ✔️ 지훈
1. 객체는 메모리상 어디에 생성되는가, 또 어떻게 메모리를 해제하는가 
   - heap영역에 저장되고, 스택영역에 번지수가 저장됨.
   - 직접 참조 해제함.(참조 변수를 null로 초기화) ->GC에 의해 메모리 할당 해제됨
     - 이 방법은 프로그램을 지저분하게 만듦.
   - 변수선언과 동시에 초기화 사용 -> 그 변수에 대한 scope이 종료되는 순간 참조가 해제되어 GC의 대상이 됨.
     - 변수의 범위를 최소가 되게 정의
2. Call by value 와 Call by Reference 차이, 자바의 call by reference
   - Call by value, Call by Reference 란 메서드 호출할 때 파라미터를 전달하는 방법
     - Call by Value
       - 메서드를 호출할 때 값을 넘겨주는 것. 값만 전달해주기 때문에 수신자의 파라미터를 수정해도 호출자의 변수는 영향가지않음
     - Call by Reference
       - 참조값(주소)를 직접 전달. 참조를 직접 넘기기 때문에 호출자의 변수와 수신자의 파라미터와 완전 동일
       - 자바는 오직 Call by value(값이 수정되는데도? )
       - 참조 값을 "복사"해서 넘김
3. 자바에서 파라미터로 객체를 넘기는 것은 Call by Reference인가
   1. 자바는 모두 Call by value. 주소값을 복사해서 넘기기 때문
   2. 복사된 주소 값으로 참조가 가능하기 때문에 call by Reference와 헷갈릴 수 있음.
   3. 
4. 객체지향의 특징 중 캡슐화와 은닉성에 대해 설명하시오.
   1. 캡슐화
      - 객체의 속성과 행위를 하나로 묶고, 실제 구현 내용 일부를 외부에 감추어 은닉
   2. 은닉성 
      - 외부에서 객체의 속성을 함부로 접근하지 못하게 하는 것.
***
### ✔️ 지우
1. nullPointerException은 언제 발생하는지 설명해주세요.
   - 정의하지 않은 변수를 참조하려고 할 때
2. 배열 변수를 선언한 시점과 값을 대입하는 시점이 다를 시 값을 대입하는 법을 설명해주세요.
   - 타입[] 변수 = new 타입[길이];
3. 캡슐화에 대해 설명해주세요.
   - 위에서 기술
4. 라이브러리 클래스와 실행 클래스에 대해 설명해주세요.
    - p.211
   1. 라이브러리클래스
        - 실행할 수 없으며 다른 클래스에서 이용하는 클래스
   2. 실행클래스 
      - main()메소드를 가지고 있는 실행 가능한 클래스.
   일반적으로 자바 프로그램은 하나의 실행 클래스와 여러개의 라이브러리 클래스로 구성되며, 실행 클래스는 실행하면서 라이브러리 클래스를 내부에서 이용함.
5. getter와 setter에 대해 설명해주세요.
   - 객체의 필드를 외부에서 마음대로 읽고 변경할 경우, 객체의 무결성이 깨질 수 있다.(p.269)
     - 따라서 접근 제한자를 통해 필드 자체의 값 접근 막음(private).
     - 외부에서 직접적인 필드 접근 막고 대신 메서드 통해 필드에 접근하도록 함 -> setter
     - 필드값이 객체 외부에서 사용하기 부적절한 경우, 메서드로 적절한 값으로 변환해서 리턴. -> getter 
***
### ✔️ 미나
1. JVM의 메모리 영역에 대해 설명해주세요.
   - 앞에서 설명 
2. String 객체 생성시, new연산자를 쓰면 같은 문자열이더라도 서로 다른 번지를 가진다.
    <br> 이때 equals를 사용하여 비교하면 true가 나오는데, 그렇게 나올 수 있는 이유는?
   - java에서의 String은 immutable
   - String constant pool에서 관리 됨. (Heap영역)
   - String 클래스에서 equals()메서드를 보면, 먼저 "=="연산자를 이용해 값은 주소값을 비교한다
   - 같은 값을 가르키지 않으면 두 객체의 내용을 비교하기 위헤 bytecode를 비교하여 동일 여부 판단  
3. static 키워드에 대해 설명해주세요.
   - static을 붙이면 JVM이 실행될 때 class가 method area에 저장. 프로그램이 끝날 때 까지 사라지지않고 메모리에 남이있음.
   - 속도가 빨라지고 반복적인 사용(공유)에 효율적
   - 객체지향 관점에서 멀어짐 (오버라이딩, 동적바인딩 불가 -> 다형성 위반)
   - 프로그램 종료시까지 메모리에서 해제되지 않으므로 메모리 관리 부분에서 효율성 떨어짐
   - 동시성 이유문제가 있음(전역접근 가능하므로..)-> 테스트어려움
4. this 키워드에 대해 설명해주세요.
   - this는 인스턴스 자신을 가리키는 참조변수
   - this()는 같은 클래스의 다른 생성자 호출 시 사용.